import { existsSync, mkdirSync, writeFileSync, readdirSync } from 'fs';
import { join, dirname, basename, resolve } from 'path';
import { FacetParser } from '../../core/FacetParser.js';
import type { FacetStructure, Facet } from '../../types.js';

interface GenerateOptions {
  output?: string;
  type?: string;
  noTypes?: boolean;
}

/**
 * Convert a facet ID to a valid TypeScript identifier
 * e.g., "business:guest-purchase-flow" -> "BUSINESS_GUEST_PURCHASE_FLOW"
 */
function toConstantName(facetId: string): string {
  return facetId
    .toUpperCase()
    .replace(/[:-]/g, '_')
    .replace(/[^A-Z0-9_]/g, '');
}

/**
 * Generate TypeScript types file from facets
 */
function generateTypesFile(facets: Facet[], featureName: string): string {
  const facetIds = facets.map(f => f.id);

  // Generate the union type
  const unionType = facetIds.length > 0
    ? facetIds.map(id => `  | '${id}'`).join('\n')
    : "  | never";

  // Generate constants for each facet ID (for autocomplete)
  const constants = facets.map(f => {
    const constName = toConstantName(f.id);
    const comment = f.title ? ` /** ${f.title} */` : '';
    return `${comment}\n  ${constName}: '${f.id}' as const,`;
  }).join('\n');

  // Generate the types file content
  return `/**
 * Auto-generated Facet types for feature: ${featureName}
 * Generated by: bunx facet generate
 *
 * DO NOT EDIT THIS FILE MANUALLY
 */

/**
 * All valid facet IDs for the "${featureName}" feature
 */
export type FacetId =
${unionType};

/**
 * Facet ID constants for autocomplete and type-safe references
 */
export const Facets = {
${constants}
} as const;

/**
 * Type-safe facet annotation helper
 * Works with any testing framework
 *
 * @example
 * // Use with constants (recommended - full autocomplete)
 * // @facet \${Facets.BUSINESS_GUEST_PURCHASE_FLOW}
 * test('my test', () => { ... });
 *
 * @example
 * // Use with facet() for runtime metadata
 * const metadata = facet(Facets.BUSINESS_GUEST_PURCHASE_FLOW, Facets.COMPLIANCE_PCI_DSS);
 */
export function facet<T extends FacetId>(...facetIds: T[]): { facets: T[]; toString: () => string } {
  return {
    facets: facetIds,
    toString: () => facetIds.join(', '),
  };
}

/**
 * Get all facet IDs as an array
 */
export const allFacetIds: FacetId[] = [
${facetIds.map(id => `  '${id}',`).join('\n')}
];
`;
}

/**
 * Generate structure.json from facet markdown files
 */
export async function generateCommand(dir: string, options: GenerateOptions = {}): Promise<void> {
  const facetsDir = resolve(process.cwd(), dir);

  if (!existsSync(facetsDir)) {
    console.error(`âŒ Directory not found: ${facetsDir}`);
    process.exit(1);
  }

  console.log(`ðŸ’Ž Generating structure from: ${facetsDir}`);

  // Find all markdown files in the directory
  const files = readdirSync(facetsDir).filter(f => f.endsWith('.md'));

  if (files.length === 0) {
    console.error(`âŒ No markdown files found in: ${facetsDir}`);
    process.exit(1);
  }

  const parser = new FacetParser();
  const facets: Facet[] = [];

  for (const file of files) {
    const filePath = join(facetsDir, file);
    const parsed = parser.parseFile(filePath);

    // Determine facet type from filename (e.g., business.md -> business)
    const type = options.type || basename(file, '.md');

    console.log(`  ðŸ“„ ${file}`);

    for (const section of parsed.sections) {
      // Only include top-level sections (h2 or the first h1 if no h2s)
      if (section.level <= 2) {
        const facetId = FacetParser.generateFacetId(file, section.slug);

        facets.push({
          id: facetId,
          source: {
            file: `facets/${file}`,
            section: section.slug,
          },
          type,
          title: section.title,
        });

        console.log(`    âœ“ ${facetId}`);
      }
    }
  }

  // Determine feature name from parent directory
  const featureDir = dirname(facetsDir);
  const featureName = basename(featureDir);

  // Build structure object
  const structure: FacetStructure = {
    feature: featureName,
    facets,
  };

  // Determine output path
  const outputDir = options.output || join(featureDir, '.facet');
  const outputPath = join(outputDir, 'structure.json');

  // Ensure output directory exists
  mkdirSync(outputDir, { recursive: true });

  // Write structure file
  writeFileSync(outputPath, JSON.stringify(structure, null, 2));

  console.log(`\nâœ… Generated: ${outputPath}`);
  console.log(`   Feature: ${featureName}`);
  console.log(`   Facets: ${facets.length}`);

  // Generate TypeScript types file (unless disabled)
  if (!options.noTypes) {
    const typesContent = generateTypesFile(facets, featureName);
    const typesPath = join(outputDir, 'facets.ts');
    writeFileSync(typesPath, typesContent);
    console.log(`   Types: ${typesPath}`);
  }
}
