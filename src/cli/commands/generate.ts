import { existsSync, mkdirSync, writeFileSync, readdirSync, statSync } from 'fs';
import { join, dirname, basename, resolve, relative } from 'path';
import { glob } from 'glob';
import { FacetParser } from '../../core/FacetParser.js';
import { IDChangeDetector } from '../../core/IDChangeDetector.js';
import { TestScanner } from '../../core/TestScanner.js';
import type { FacetStructure, Facet, FacetConfig } from '../../types.js';
import { loadConfig } from '../utils/config.js';

interface GenerateOptions {
  output?: string;
  type?: string;
  noTypes?: boolean;
  config?: string;
  global?: boolean;
  quiet?: boolean;
}

/**
 * Convert a facet ID to a valid TypeScript identifier.
 *
 * Uses these conventions:
 * - `:` and `-` become single underscore `_`
 * - `/` in path (before `:`) becomes single underscore `_`
 * - `/` after `:` (sub-facet separator) becomes double underscore `__`
 *
 * Examples:
 * - "business:guest-purchase-flow" -> "BUSINESS_GUEST_PURCHASE_FLOW"
 * - "checkout/payments/pci:card-storage" -> "CHECKOUT_PAYMENTS_PCI_CARD_STORAGE"
 * - "compliance:pci-dss/tls" -> "COMPLIANCE_PCI_DSS__TLS" (sub-facet uses __)
 */
function toConstantName(facetId: string): string {
  const colonIndex = facetId.indexOf(':');

  if (colonIndex === -1) {
    // No colon, simple conversion
    return facetId.toUpperCase().replace(/[/-]/g, '_').replace(/[^A-Z0-9_]/g, '');
  }

  // Split into path+type part and section part
  const pathAndType = facetId.substring(0, colonIndex);
  const section = facetId.substring(colonIndex + 1);

  // For path+type: / and - become _
  const pathPart = pathAndType.toUpperCase().replace(/[/-]/g, '_').replace(/[^A-Z0-9_]/g, '');

  // For section: - becomes _, / becomes __ (sub-facet separator)
  const sectionPart = section.toUpperCase().replace(/\//g, '__').replace(/-/g, '_').replace(/[^A-Z0-9_]/g, '');

  return `${pathPart}_${sectionPart}`;
}

/**
 * Escape a title for use in JSDoc comments.
 * Removes backticks and other problematic characters.
 */
function escapeJsDocTitle(title: string): string {
  return title
    .replace(/`/g, "'") // Replace backticks with single quotes
    .replace(/\*/g, '') // Remove asterisks (would close JSDoc)
    .replace(/\n/g, ' ') // Replace newlines with spaces
    .trim();
}

/**
 * Generate TypeScript types file from facets
 */
function generateTypesFile(facets: Facet[], featureName: string): string {
  const facetIds = facets.map(f => f.id);

  // Generate the union type
  const unionType = facetIds.length > 0
    ? facetIds.map(id => `  | '${id}'`).join('\n')
    : "  | never";

  // Generate constants for each facet ID (for autocomplete)
  const constants = facets.map(f => {
    const constName = toConstantName(f.id);
    const comment = f.title ? ` /** ${escapeJsDocTitle(f.title)} */` : '';
    return `${comment}\n  ${constName}: '${f.id}' as const,`;
  }).join('\n');

  // Generate the types file content
  return `/**
 * Auto-generated Facet types for feature: ${featureName}
 * Generated by: bunx facet generate
 *
 * DO NOT EDIT THIS FILE MANUALLY
 */

/**
 * All valid facet IDs for the "${featureName}" feature
 */
export type FacetId =
${unionType};

/**
 * Facet ID constants for autocomplete and type-safe references
 */
export const Facets = {
${constants}
} as const;

/**
 * Type-safe facet annotation helper
 * Works with any testing framework including Playwright
 *
 * @example
 * // Use with Playwright test annotations
 * test('my test', {
 *   annotation: facet(Facets.BUSINESS_GUEST_PURCHASE_FLOW)
 * }, async ({ page }) => { ... });
 *
 * @example
 * // Use with constants (recommended - full autocomplete)
 * // @facet \${Facets.BUSINESS_GUEST_PURCHASE_FLOW}
 * test('my test', () => { ... });
 *
 * @example
 * // Use with facet() for runtime metadata
 * const metadata = facet(Facets.BUSINESS_GUEST_PURCHASE_FLOW, Facets.COMPLIANCE_PCI_DSS);
 */
export function facet<T extends FacetId>(...facetIds: T[]): {
  type: 'facet-coverage';
  description: string;
  facets: T[];
  toString: () => string;
} {
  return {
    type: 'facet-coverage',
    description: facetIds.join(','),
    facets: facetIds,
    toString: () => facetIds.join(', '),
  };
}

/**
 * Get all facet IDs as an array
 */
export const allFacetIds: FacetId[] = [
${facetIds.map(id => `  '${id}',`).join('\n')}
];
`;
}

/**
 * Generate global types file that combines all features
 */
function generateGlobalTypesFile(
  allFacets: Facet[],
  featureImports: Map<string, string>
): string {
  const facetIds = allFacets.map(f => f.id);

  // Generate the union type
  const unionType = facetIds.length > 0
    ? facetIds.map(id => `  | '${id}'`).join('\n')
    : "  | never";

  // Generate constants for each facet ID
  const constants = allFacets.map(f => {
    const constName = toConstantName(f.id);
    const comment = f.title ? ` /** ${escapeJsDocTitle(f.title)} */` : '';
    return `${comment}\n  ${constName}: '${f.id}' as const,`;
  }).join('\n');

  // Generate re-exports for each feature
  const reExports = Array.from(featureImports.entries())
    .map(([feature, path]) => `export * as ${feature} from '${path}';`)
    .join('\n');

  return `/**
 * Auto-generated Global Facet types
 * Combines all features for single import point
 *
 * Generated by: bunx facet generate --global
 * DO NOT EDIT THIS FILE MANUALLY
 */

// Re-export all feature-specific types
${reExports}

/**
 * All valid facet IDs across ALL features
 */
export type FacetId =
${unionType};

/**
 * Combined Facet ID constants from all features
 */
export const Facets = {
${constants}
} as const;

/**
 * Type-safe facet annotation helper (global version)
 * Works with any testing framework including Playwright
 */
export function facet<T extends FacetId>(...facetIds: T[]): {
  type: 'facet-coverage';
  description: string;
  facets: T[];
  toString: () => string;
} {
  return {
    type: 'facet-coverage',
    description: facetIds.join(','),
    facets: facetIds,
    toString: () => facetIds.join(', '),
  };
}

/**
 * All facet IDs across all features
 */
export const allFacetIds: FacetId[] = [
${facetIds.map(id => `  '${id}',`).join('\n')}
];
`;
}

/**
 * Get facet type from file path.
 * Handles both .facet.md and .md extensions.
 */
function getFacetType(filePath: string, options: GenerateOptions): string {
  if (options.type) {
    return options.type;
  }
  return FacetParser.getFilePrefix(filePath);
}

/**
 * Find facet files in a directory (both conventions)
 */
function findFacetFilesInDir(dir: string): string[] {
  const files: string[] = [];

  // Find *.facet.md files in the directory
  const entries = readdirSync(dir, { withFileTypes: true });
  for (const entry of entries) {
    if (entry.isFile()) {
      if (entry.name.endsWith('.facet.md') || entry.name.endsWith('.md')) {
        files.push(join(dir, entry.name));
      }
    }
  }

  return files;
}

/**
 * Recursively discover all facet files matching patterns
 */
async function discoverFacetFiles(
  rootDir: string,
  patterns: string[]
): Promise<string[]> {
  const allFiles: string[] = [];

  for (const pattern of patterns) {
    const matches = await glob(pattern, { cwd: rootDir, absolute: true });
    allFiles.push(...matches);
  }

  // Remove duplicates
  return [...new Set(allFiles)];
}

/**
 * Group facet files by their feature directory
 */
function groupByFeature(files: string[], rootDir: string): Map<string, string[]> {
  const groups = new Map<string, string[]>();

  for (const file of files) {
    // Determine feature directory
    let featureDir: string;
    const fileDir = dirname(file);

    if (basename(fileDir) === 'facets') {
      // Legacy: features/checkout/facets/business.md -> features/checkout
      featureDir = dirname(fileDir);
    } else {
      // New: features/checkout/business.facet.md -> features/checkout
      featureDir = fileDir;
    }

    const existing = groups.get(featureDir) || [];
    existing.push(file);
    groups.set(featureDir, existing);
  }

  return groups;
}

/**
 * Process a single feature directory and generate outputs
 */
async function processFeature(
  featureDir: string,
  files: string[],
  rootDir: string,
  options: GenerateOptions,
  config?: FacetConfig
): Promise<{ facets: Facet[]; outputDir: string }> {
  const parser = new FacetParser();
  const facets: Facet[] = [];
  const featureName = basename(featureDir);

  console.log(`\n  Feature: ${featureName}`);

  // Get configured sub-facet heading levels (default: none - only list items and comment markers)
  const subFacetHeadingLevels = config?.subFacetHeadingLevels || [];

  for (const filePath of files) {
    const parsed = parser.parseFile(filePath);
    const type = getFacetType(filePath, options);
    const fileName = basename(filePath);

    console.log(`    üìÑ ${fileName}`);

    // Track current parent facet for h3+ sub-facets
    let currentParentFacetId: string | null = null;
    let currentParentSection: string | null = null;

    // Determine relative source path
    const sourcePath = FacetParser.isFacetMdFile(filePath)
      ? fileName
      : `facets/${fileName}`;

    for (const section of parsed.sections) {
      // Use hierarchical ID if nested, simple ID otherwise
      const relPath = relative(rootDir, featureDir);
      const isNested = relPath.includes('/') || relPath !== basename(featureDir);

      // Check if this section level should be a sub-facet
      const isSubFacetLevel = subFacetHeadingLevels.includes(section.level);

      // Top-level sections (h2 or h1) become parent facets
      if (section.level <= 2) {
        const facetId = isNested
          ? FacetParser.generateHierarchicalFacetId(rootDir, filePath, section.slug)
          : FacetParser.generateFacetId(filePath, section.slug);

        // Add parent facet
        facets.push({
          id: facetId,
          source: {
            file: sourcePath,
            section: section.slug,
          },
          type,
          title: section.title,
        });

        console.log(`      ‚úì ${facetId}`);

        // Track as current parent for h3+ sections
        currentParentFacetId = facetId;
        currentParentSection = section.slug;

        // Process sub-facets from list items and comments if present
        if (section.subFacets && section.subFacets.length > 0) {
          for (const subFacet of section.subFacets) {
            const subFacetId = FacetParser.generateSubFacetId(facetId, subFacet.id);

            facets.push({
              id: subFacetId,
              source: {
                file: sourcePath,
                section: section.slug,
                line: subFacet.line,
              },
              type,
              title: subFacet.title,
              parentId: facetId,
              isSubFacet: true,
            });

            console.log(`        ‚îî‚îÄ ${subFacetId}`);
          }
        }
      }
      // h3+ sections with explicit IDs become sub-facets if configured
      else if (isSubFacetLevel && section.explicitId && currentParentFacetId) {
        const subFacetId = FacetParser.generateSubFacetId(currentParentFacetId, section.explicitId);

        facets.push({
          id: subFacetId,
          source: {
            file: sourcePath,
            section: currentParentSection || section.slug,
            line: section.startLine,
          },
          type,
          title: section.title,
          parentId: currentParentFacetId,
          isSubFacet: true,
        });

        console.log(`        ‚îî‚îÄ ${subFacetId}`);

        // Also process any sub-facets within this h3+ section (list items, comments)
        if (section.subFacets && section.subFacets.length > 0) {
          for (const subFacet of section.subFacets) {
            const nestedSubFacetId = FacetParser.generateSubFacetId(subFacetId, subFacet.id);

            facets.push({
              id: nestedSubFacetId,
              source: {
                file: sourcePath,
                section: currentParentSection || section.slug,
                line: subFacet.line,
              },
              type,
              title: subFacet.title,
              parentId: subFacetId,
              isSubFacet: true,
            });

            console.log(`          ‚îî‚îÄ ${nestedSubFacetId}`);
          }
        }
      }
      // h3+ sections without explicit IDs: attach their sub-facets to current parent
      else if (section.level > 2 && currentParentFacetId && section.subFacets && section.subFacets.length > 0) {
        for (const subFacet of section.subFacets) {
          const subFacetId = FacetParser.generateSubFacetId(currentParentFacetId, subFacet.id);

          facets.push({
            id: subFacetId,
            source: {
              file: sourcePath,
              section: currentParentSection || section.slug,
              line: subFacet.line,
            },
            type,
            title: subFacet.title,
            parentId: currentParentFacetId,
            isSubFacet: true,
          });

          console.log(`        ‚îî‚îÄ ${subFacetId}`);
        }
      }
    }
  }

  // Determine output directory
  const outputDir = options.output || join(featureDir, '.facet');

  // Build structure object
  const structure: FacetStructure = {
    feature: featureName,
    facets,
  };

  // Ensure output directory exists
  mkdirSync(outputDir, { recursive: true });

  // Write structure file
  const structurePath = join(outputDir, 'structure.json');

  // Detect ID changes before writing
  if (!options.quiet) {
    const changeReport = IDChangeDetector.detectChanges(structurePath, facets);
    if (changeReport.hasChanges) {
      console.log('\n    ‚ö†Ô∏è  Facet ID Changes Detected:');
      const reportLines = IDChangeDetector.formatReport(changeReport);
      for (const line of reportLines) {
        console.log(line);
      }

      // Show affected tests if we have config
      if (config && (changeReport.renamed.length > 0 || changeReport.removed.length > 0)) {
        const scanner = new TestScanner(config);
        const affected = await IDChangeDetector.findAffectedTests(changeReport, scanner, rootDir);
        if (affected.size > 0) {
          console.log('\n    Tests that may need updates:');
          for (const [oldId, tests] of affected) {
            console.log(`\n      For "${oldId}":`);
            for (const test of tests) {
              console.log(`        - ${test.file}:${test.line} "${test.title}"`);
            }
          }
        }
      }
      console.log('');
    }
  }

  writeFileSync(structurePath, JSON.stringify(structure, null, 2));

  // Generate TypeScript types file (unless disabled)
  if (!options.noTypes) {
    const typesContent = generateTypesFile(facets, featureName);
    const typesPath = join(outputDir, 'facets.ts');
    writeFileSync(typesPath, typesContent);
  }

  console.log(`    ‚úÖ Generated: ${relative(process.cwd(), outputDir)}`);

  return { facets, outputDir };
}

/**
 * Generate from explicit directory (backwards compatible)
 */
async function generateFromDirectory(
  dir: string,
  options: GenerateOptions,
  config?: FacetConfig
): Promise<void> {
  const facetsDir = resolve(process.cwd(), dir);

  if (!existsSync(facetsDir)) {
    console.error(`‚ùå Directory not found: ${facetsDir}`);
    process.exit(1);
  }

  console.log(`üíé Generating structure from: ${facetsDir}`);

  // Find all markdown files in the directory
  const files = findFacetFilesInDir(facetsDir);

  if (files.length === 0) {
    console.error(`‚ùå No markdown files found in: ${facetsDir}`);
    process.exit(1);
  }

  const parser = new FacetParser();
  const facets: Facet[] = [];

  // Get configured sub-facet heading levels (default: none)
  const subFacetHeadingLevels = config?.subFacetHeadingLevels || [];

  for (const filePath of files) {
    const parsed = parser.parseFile(filePath);
    const file = basename(filePath);
    const type = getFacetType(filePath, options);

    console.log(`  üìÑ ${file}`);

    // Track current parent facet for h3+ sub-facets
    let currentParentFacetId: string | null = null;
    let currentParentSection: string | null = null;

    // Determine source path based on file type
    const sourcePath = FacetParser.isFacetMdFile(filePath)
      ? file
      : `facets/${file}`;

    for (const section of parsed.sections) {
      // Check if this section level should be a sub-facet
      const isSubFacetLevel = subFacetHeadingLevels.includes(section.level);

      // Top-level sections (h2 or h1) become parent facets
      if (section.level <= 2) {
        const facetId = FacetParser.generateFacetId(file, section.slug);

        facets.push({
          id: facetId,
          source: {
            file: sourcePath,
            section: section.slug,
          },
          type,
          title: section.title,
        });

        console.log(`    ‚úì ${facetId}`);

        // Track as current parent for h3+ sections
        currentParentFacetId = facetId;
        currentParentSection = section.slug;

        // Process sub-facets from list items and comments if present
        if (section.subFacets && section.subFacets.length > 0) {
          for (const subFacet of section.subFacets) {
            const subFacetId = FacetParser.generateSubFacetId(facetId, subFacet.id);

            facets.push({
              id: subFacetId,
              source: {
                file: sourcePath,
                section: section.slug,
                line: subFacet.line,
              },
              type,
              title: subFacet.title,
              parentId: facetId,
              isSubFacet: true,
            });

            console.log(`      ‚îî‚îÄ ${subFacetId}`);
          }
        }
      }
      // h3+ sections with explicit IDs become sub-facets if configured
      else if (isSubFacetLevel && section.explicitId && currentParentFacetId) {
        const subFacetId = FacetParser.generateSubFacetId(currentParentFacetId, section.explicitId);

        facets.push({
          id: subFacetId,
          source: {
            file: sourcePath,
            section: currentParentSection || section.slug,
            line: section.startLine,
          },
          type,
          title: section.title,
          parentId: currentParentFacetId,
          isSubFacet: true,
        });

        console.log(`      ‚îî‚îÄ ${subFacetId}`);

        // Also process any sub-facets within this h3+ section
        if (section.subFacets && section.subFacets.length > 0) {
          for (const subFacet of section.subFacets) {
            const nestedSubFacetId = FacetParser.generateSubFacetId(subFacetId, subFacet.id);

            facets.push({
              id: nestedSubFacetId,
              source: {
                file: sourcePath,
                section: currentParentSection || section.slug,
                line: subFacet.line,
              },
              type,
              title: subFacet.title,
              parentId: subFacetId,
              isSubFacet: true,
            });

            console.log(`        ‚îî‚îÄ ${nestedSubFacetId}`);
          }
        }
      }
      // h3+ sections without explicit IDs: attach their sub-facets to current parent
      else if (section.level > 2 && currentParentFacetId && section.subFacets && section.subFacets.length > 0) {
        for (const subFacet of section.subFacets) {
          const subFacetId = FacetParser.generateSubFacetId(currentParentFacetId, subFacet.id);

          facets.push({
            id: subFacetId,
            source: {
              file: sourcePath,
              section: currentParentSection || section.slug,
              line: subFacet.line,
            },
            type,
            title: subFacet.title,
            parentId: currentParentFacetId,
            isSubFacet: true,
          });

          console.log(`      ‚îî‚îÄ ${subFacetId}`);
        }
      }
    }
  }

  // Determine feature name from parent directory
  const featureDir = dirname(facetsDir);
  const featureName = basename(featureDir);

  // Build structure object
  const structure: FacetStructure = {
    feature: featureName,
    facets,
  };

  // Determine output path
  const outputDir = options.output || join(featureDir, '.facet');
  const outputPath = join(outputDir, 'structure.json');

  // Ensure output directory exists
  mkdirSync(outputDir, { recursive: true });

  // Write structure file
  writeFileSync(outputPath, JSON.stringify(structure, null, 2));

  console.log(`\n‚úÖ Generated: ${outputPath}`);
  console.log(`   Feature: ${featureName}`);
  console.log(`   Facets: ${facets.length}`);

  // Generate TypeScript types file (unless disabled)
  if (!options.noTypes) {
    const typesContent = generateTypesFile(facets, featureName);
    const typesPath = join(outputDir, 'facets.ts');
    writeFileSync(typesPath, typesContent);
    console.log(`   Types: ${typesPath}`);
  }
}

/**
 * Generate from config patterns
 */
async function generateFromConfig(
  config: FacetConfig,
  options: GenerateOptions
): Promise<void> {
  const cwd = process.cwd();

  // Get facet patterns from config
  const patterns = Array.isArray(config.facetPattern)
    ? config.facetPattern
    : config.facetPattern
      ? [config.facetPattern]
      : ['features/**/*.facet.md', 'features/**/facets/*.md'];

  console.log('üíé Discovering facet files...\n');

  // Find all matching files
  const files = await discoverFacetFiles(cwd, patterns);

  if (files.length === 0) {
    console.error('‚ùå No facet files found matching patterns:');
    for (const pattern of patterns) {
      console.error(`   - ${pattern}`);
    }
    console.error('\nMake sure facet files exist or specify a directory explicitly:');
    console.error('  bunx facet generate features/checkout/facets/');
    process.exit(1);
  }

  console.log(`Found ${files.length} facet file(s)`);

  // Group files by feature
  const featureGroups = groupByFeature(files, cwd);
  const allFacets: Facet[] = [];
  const featureOutputs = new Map<string, string>();

  // Process each feature
  for (const [featureDir, featureFiles] of featureGroups) {
    const { facets, outputDir } = await processFeature(
      featureDir,
      featureFiles,
      cwd,
      options,
      config
    );
    allFacets.push(...facets);

    // Store for global types
    const featureName = basename(featureDir);
    const relativeOutput = relative(join(cwd, '.facet'), join(outputDir, 'facets'));
    featureOutputs.set(featureName, relativeOutput);
  }

  // Generate global types if requested
  if (options.global && !options.noTypes) {
    const globalOutputDir = join(cwd, '.facet');
    mkdirSync(globalOutputDir, { recursive: true });

    const globalTypesContent = generateGlobalTypesFile(allFacets, featureOutputs);
    const globalTypesPath = join(globalOutputDir, 'facets.ts');
    writeFileSync(globalTypesPath, globalTypesContent);

    console.log(`\n‚úÖ Generated global types: ${relative(cwd, globalTypesPath)}`);
  }

  // Summary
  console.log(`\nüìä Summary:`);
  console.log(`   Features: ${featureGroups.size}`);
  console.log(`   Total Facets: ${allFacets.length}`);
}

/**
 * Generate structure.json and TypeScript types from facet markdown files
 */
export async function generateCommand(
  dir?: string,
  options: GenerateOptions = {}
): Promise<void> {
  const cwd = process.cwd();

  // Always try to load config for options like subFacetHeadingLevels
  const config = await loadConfig(options.config, cwd);

  if (dir) {
    // Backwards compatible: explicit directory provided, but pass config for options
    await generateFromDirectory(dir, options, config);
  } else {
    // New behavior: use config to find facet files
    await generateFromConfig(config, options);
  }
}
