import { existsSync, mkdirSync, writeFileSync, readdirSync, statSync } from 'fs';
import { join, dirname, basename, resolve, relative } from 'path';
import { glob } from 'glob';
import { FacetParser } from '../../core/FacetParser.js';
import { IDChangeDetector } from '../../core/IDChangeDetector.js';
import { TestScanner } from '../../core/TestScanner.js';
import type { FacetStructure, Facet, FacetConfig } from '../../types.js';
import { loadConfig } from '../utils/config.js';

interface GenerateOptions {
  output?: string;
  type?: string;
  noTypes?: boolean;
  config?: string;
  global?: boolean;
  quiet?: boolean;
}

/**
 * Convert a facet ID to a valid TypeScript identifier
 * e.g., "business:guest-purchase-flow" -> "BUSINESS_GUEST_PURCHASE_FLOW"
 * e.g., "checkout/payments/pci:card-storage" -> "CHECKOUT_PAYMENTS_PCI_CARD_STORAGE"
 */
function toConstantName(facetId: string): string {
  return facetId
    .toUpperCase()
    .replace(/[/:-]/g, '_')
    .replace(/[^A-Z0-9_]/g, '');
}

/**
 * Generate TypeScript types file from facets
 */
function generateTypesFile(facets: Facet[], featureName: string): string {
  const facetIds = facets.map(f => f.id);

  // Generate the union type
  const unionType = facetIds.length > 0
    ? facetIds.map(id => `  | '${id}'`).join('\n')
    : "  | never";

  // Generate constants for each facet ID (for autocomplete)
  const constants = facets.map(f => {
    const constName = toConstantName(f.id);
    const comment = f.title ? ` /** ${f.title} */` : '';
    return `${comment}\n  ${constName}: '${f.id}' as const,`;
  }).join('\n');

  // Generate the types file content
  return `/**
 * Auto-generated Facet types for feature: ${featureName}
 * Generated by: bunx facet generate
 *
 * DO NOT EDIT THIS FILE MANUALLY
 */

/**
 * All valid facet IDs for the "${featureName}" feature
 */
export type FacetId =
${unionType};

/**
 * Facet ID constants for autocomplete and type-safe references
 */
export const Facets = {
${constants}
} as const;

/**
 * Type-safe facet annotation helper
 * Works with any testing framework
 *
 * @example
 * // Use with constants (recommended - full autocomplete)
 * // @facet \${Facets.BUSINESS_GUEST_PURCHASE_FLOW}
 * test('my test', () => { ... });
 *
 * @example
 * // Use with facet() for runtime metadata
 * const metadata = facet(Facets.BUSINESS_GUEST_PURCHASE_FLOW, Facets.COMPLIANCE_PCI_DSS);
 */
export function facet<T extends FacetId>(...facetIds: T[]): { facets: T[]; toString: () => string } {
  return {
    facets: facetIds,
    toString: () => facetIds.join(', '),
  };
}

/**
 * Get all facet IDs as an array
 */
export const allFacetIds: FacetId[] = [
${facetIds.map(id => `  '${id}',`).join('\n')}
];
`;
}

/**
 * Generate global types file that combines all features
 */
function generateGlobalTypesFile(
  allFacets: Facet[],
  featureImports: Map<string, string>
): string {
  const facetIds = allFacets.map(f => f.id);

  // Generate the union type
  const unionType = facetIds.length > 0
    ? facetIds.map(id => `  | '${id}'`).join('\n')
    : "  | never";

  // Generate constants for each facet ID
  const constants = allFacets.map(f => {
    const constName = toConstantName(f.id);
    const comment = f.title ? ` /** ${f.title} */` : '';
    return `${comment}\n  ${constName}: '${f.id}' as const,`;
  }).join('\n');

  // Generate re-exports for each feature
  const reExports = Array.from(featureImports.entries())
    .map(([feature, path]) => `export * as ${feature} from '${path}';`)
    .join('\n');

  return `/**
 * Auto-generated Global Facet types
 * Combines all features for single import point
 *
 * Generated by: bunx facet generate --global
 * DO NOT EDIT THIS FILE MANUALLY
 */

// Re-export all feature-specific types
${reExports}

/**
 * All valid facet IDs across ALL features
 */
export type FacetId =
${unionType};

/**
 * Combined Facet ID constants from all features
 */
export const Facets = {
${constants}
} as const;

/**
 * Type-safe facet annotation helper (global version)
 */
export function facet<T extends FacetId>(...facetIds: T[]): { facets: T[]; toString: () => string } {
  return {
    facets: facetIds,
    toString: () => facetIds.join(', '),
  };
}

/**
 * All facet IDs across all features
 */
export const allFacetIds: FacetId[] = [
${facetIds.map(id => `  '${id}',`).join('\n')}
];
`;
}

/**
 * Get facet type from file path.
 * Handles both .facet.md and .md extensions.
 */
function getFacetType(filePath: string, options: GenerateOptions): string {
  if (options.type) {
    return options.type;
  }
  return FacetParser.getFilePrefix(filePath);
}

/**
 * Find facet files in a directory (both conventions)
 */
function findFacetFilesInDir(dir: string): string[] {
  const files: string[] = [];

  // Find *.facet.md files in the directory
  const entries = readdirSync(dir, { withFileTypes: true });
  for (const entry of entries) {
    if (entry.isFile()) {
      if (entry.name.endsWith('.facet.md') || entry.name.endsWith('.md')) {
        files.push(join(dir, entry.name));
      }
    }
  }

  return files;
}

/**
 * Recursively discover all facet files matching patterns
 */
async function discoverFacetFiles(
  rootDir: string,
  patterns: string[]
): Promise<string[]> {
  const allFiles: string[] = [];

  for (const pattern of patterns) {
    const matches = await glob(pattern, { cwd: rootDir, absolute: true });
    allFiles.push(...matches);
  }

  // Remove duplicates
  return [...new Set(allFiles)];
}

/**
 * Group facet files by their feature directory
 */
function groupByFeature(files: string[], rootDir: string): Map<string, string[]> {
  const groups = new Map<string, string[]>();

  for (const file of files) {
    // Determine feature directory
    let featureDir: string;
    const fileDir = dirname(file);

    if (basename(fileDir) === 'facets') {
      // Legacy: features/checkout/facets/business.md -> features/checkout
      featureDir = dirname(fileDir);
    } else {
      // New: features/checkout/business.facet.md -> features/checkout
      featureDir = fileDir;
    }

    const existing = groups.get(featureDir) || [];
    existing.push(file);
    groups.set(featureDir, existing);
  }

  return groups;
}

/**
 * Process a single feature directory and generate outputs
 */
async function processFeature(
  featureDir: string,
  files: string[],
  rootDir: string,
  options: GenerateOptions,
  config?: FacetConfig
): Promise<{ facets: Facet[]; outputDir: string }> {
  const parser = new FacetParser();
  const facets: Facet[] = [];
  const featureName = basename(featureDir);

  console.log(`\n  Feature: ${featureName}`);

  for (const filePath of files) {
    const parsed = parser.parseFile(filePath);
    const type = getFacetType(filePath, options);
    const fileName = basename(filePath);

    console.log(`    üìÑ ${fileName}`);

    for (const section of parsed.sections) {
      // Only include top-level sections (h2 or the first h1 if no h2s)
      if (section.level <= 2) {
        // Use hierarchical ID if nested, simple ID otherwise
        const relPath = relative(rootDir, featureDir);
        const isNested = relPath.includes('/') || relPath !== basename(featureDir);

        const facetId = isNested
          ? FacetParser.generateHierarchicalFacetId(rootDir, filePath, section.slug)
          : FacetParser.generateFacetId(filePath, section.slug);

        // Determine relative source path
        const sourcePath = FacetParser.isFacetMdFile(filePath)
          ? fileName
          : `facets/${fileName}`;

        facets.push({
          id: facetId,
          source: {
            file: sourcePath,
            section: section.slug,
          },
          type,
          title: section.title,
        });

        console.log(`      ‚úì ${facetId}`);
      }
    }
  }

  // Determine output directory
  const outputDir = options.output || join(featureDir, '.facet');

  // Build structure object
  const structure: FacetStructure = {
    feature: featureName,
    facets,
  };

  // Ensure output directory exists
  mkdirSync(outputDir, { recursive: true });

  // Write structure file
  const structurePath = join(outputDir, 'structure.json');

  // Detect ID changes before writing
  if (!options.quiet) {
    const changeReport = IDChangeDetector.detectChanges(structurePath, facets);
    if (changeReport.hasChanges) {
      console.log('\n    ‚ö†Ô∏è  Facet ID Changes Detected:');
      const reportLines = IDChangeDetector.formatReport(changeReport);
      for (const line of reportLines) {
        console.log(line);
      }

      // Show affected tests if we have config
      if (config && (changeReport.renamed.length > 0 || changeReport.removed.length > 0)) {
        const scanner = new TestScanner(config);
        const affected = await IDChangeDetector.findAffectedTests(changeReport, scanner, rootDir);
        if (affected.size > 0) {
          console.log('\n    Tests that may need updates:');
          for (const [oldId, tests] of affected) {
            console.log(`\n      For "${oldId}":`);
            for (const test of tests) {
              console.log(`        - ${test.file}:${test.line} "${test.title}"`);
            }
          }
        }
      }
      console.log('');
    }
  }

  writeFileSync(structurePath, JSON.stringify(structure, null, 2));

  // Generate TypeScript types file (unless disabled)
  if (!options.noTypes) {
    const typesContent = generateTypesFile(facets, featureName);
    const typesPath = join(outputDir, 'facets.ts');
    writeFileSync(typesPath, typesContent);
  }

  console.log(`    ‚úÖ Generated: ${relative(process.cwd(), outputDir)}`);

  return { facets, outputDir };
}

/**
 * Generate from explicit directory (backwards compatible)
 */
async function generateFromDirectory(
  dir: string,
  options: GenerateOptions
): Promise<void> {
  const facetsDir = resolve(process.cwd(), dir);

  if (!existsSync(facetsDir)) {
    console.error(`‚ùå Directory not found: ${facetsDir}`);
    process.exit(1);
  }

  console.log(`üíé Generating structure from: ${facetsDir}`);

  // Find all markdown files in the directory
  const files = findFacetFilesInDir(facetsDir);

  if (files.length === 0) {
    console.error(`‚ùå No markdown files found in: ${facetsDir}`);
    process.exit(1);
  }

  const parser = new FacetParser();
  const facets: Facet[] = [];

  for (const filePath of files) {
    const parsed = parser.parseFile(filePath);
    const file = basename(filePath);
    const type = getFacetType(filePath, options);

    console.log(`  üìÑ ${file}`);

    for (const section of parsed.sections) {
      if (section.level <= 2) {
        const facetId = FacetParser.generateFacetId(file, section.slug);

        // Determine source path based on file type
        const sourcePath = FacetParser.isFacetMdFile(filePath)
          ? file
          : `facets/${file}`;

        facets.push({
          id: facetId,
          source: {
            file: sourcePath,
            section: section.slug,
          },
          type,
          title: section.title,
        });

        console.log(`    ‚úì ${facetId}`);
      }
    }
  }

  // Determine feature name from parent directory
  const featureDir = dirname(facetsDir);
  const featureName = basename(featureDir);

  // Build structure object
  const structure: FacetStructure = {
    feature: featureName,
    facets,
  };

  // Determine output path
  const outputDir = options.output || join(featureDir, '.facet');
  const outputPath = join(outputDir, 'structure.json');

  // Ensure output directory exists
  mkdirSync(outputDir, { recursive: true });

  // Write structure file
  writeFileSync(outputPath, JSON.stringify(structure, null, 2));

  console.log(`\n‚úÖ Generated: ${outputPath}`);
  console.log(`   Feature: ${featureName}`);
  console.log(`   Facets: ${facets.length}`);

  // Generate TypeScript types file (unless disabled)
  if (!options.noTypes) {
    const typesContent = generateTypesFile(facets, featureName);
    const typesPath = join(outputDir, 'facets.ts');
    writeFileSync(typesPath, typesContent);
    console.log(`   Types: ${typesPath}`);
  }
}

/**
 * Generate from config patterns
 */
async function generateFromConfig(
  config: FacetConfig,
  options: GenerateOptions
): Promise<void> {
  const cwd = process.cwd();

  // Get facet patterns from config
  const patterns = Array.isArray(config.facetPattern)
    ? config.facetPattern
    : config.facetPattern
      ? [config.facetPattern]
      : ['features/**/*.facet.md', 'features/**/facets/*.md'];

  console.log('üíé Discovering facet files...\n');

  // Find all matching files
  const files = await discoverFacetFiles(cwd, patterns);

  if (files.length === 0) {
    console.error('‚ùå No facet files found matching patterns:');
    for (const pattern of patterns) {
      console.error(`   - ${pattern}`);
    }
    console.error('\nMake sure facet files exist or specify a directory explicitly:');
    console.error('  bunx facet generate features/checkout/facets/');
    process.exit(1);
  }

  console.log(`Found ${files.length} facet file(s)`);

  // Group files by feature
  const featureGroups = groupByFeature(files, cwd);
  const allFacets: Facet[] = [];
  const featureOutputs = new Map<string, string>();

  // Process each feature
  for (const [featureDir, featureFiles] of featureGroups) {
    const { facets, outputDir } = await processFeature(
      featureDir,
      featureFiles,
      cwd,
      options,
      config
    );
    allFacets.push(...facets);

    // Store for global types
    const featureName = basename(featureDir);
    const relativeOutput = relative(join(cwd, '.facet'), join(outputDir, 'facets'));
    featureOutputs.set(featureName, relativeOutput);
  }

  // Generate global types if requested
  if (options.global && !options.noTypes) {
    const globalOutputDir = join(cwd, '.facet');
    mkdirSync(globalOutputDir, { recursive: true });

    const globalTypesContent = generateGlobalTypesFile(allFacets, featureOutputs);
    const globalTypesPath = join(globalOutputDir, 'facets.ts');
    writeFileSync(globalTypesPath, globalTypesContent);

    console.log(`\n‚úÖ Generated global types: ${relative(cwd, globalTypesPath)}`);
  }

  // Summary
  console.log(`\nüìä Summary:`);
  console.log(`   Features: ${featureGroups.size}`);
  console.log(`   Total Facets: ${allFacets.length}`);
}

/**
 * Generate structure.json and TypeScript types from facet markdown files
 */
export async function generateCommand(
  dir?: string,
  options: GenerateOptions = {}
): Promise<void> {
  const cwd = process.cwd();

  if (dir) {
    // Backwards compatible: explicit directory provided
    await generateFromDirectory(dir, options);
  } else {
    // New behavior: use config to find facet files
    const config = await loadConfig(options.config, cwd);
    await generateFromConfig(config, options);
  }
}
